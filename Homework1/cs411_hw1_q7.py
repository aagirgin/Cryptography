# -*- coding: utf-8 -*-
"""CS411_HW1_Q7.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14Ui9WNRHrYEsD4T5K290rTfDZ20eua_I
"""

from IPython.utils.path import get_ipython_package_dir
from typing_extensions import NewType
import math
import random
import fractions


# "ZDZUKEO.AANDOGIJTLNEKEPHZUQDX NDS VLNDJGQLYDVSBU.DER.K.UYT"
text = "ZDZUKEO.AANDOGIJTLNEKEPHZUQDX NDS VLNDJGQLYDVSBU.DER.K.UYT"

lowercase = {'a':0, 'b':1, 'c':2, 'd':3, 'e':4, 'f':5, 'g':6, 'h':7, 'i':8,
         'j':9, 'k':10, 'l':11, 'm':12, 'n':13, 'o':14, 'p':15, 'q':16,
         'r':17, 's':18,  't':19, 'u':20, 'v':21, 'w':22, 'x':23, 'y':24,
         'z':25}

uppercase ={'A':0, 'B':1, 'C':2, 'D':3, 'E':4, 'F':5, 'G':6, 'H':7, 'I':8,
         'J':9, 'K':10, 'L':11, 'M':12, 'N':13, 'O':14, 'P':15, 'Q':16,
         'R':17, 'S':18,  'T':19, 'U':20, 'V':21, 'W':22, 'X':23, 'Y':24,
         'Z':25}

inv_lowercase = {0:'a', 1:'b', 2:'c', 3:'d', 4:'e', 5:'f', 6:'g', 7:'h', 8:'i',
         9:'j', 10:'k', 11:'l', 12:'m', 13:'n', 14:'o', 15:'p', 16:'q',
         17:'r', 18:'s', 19:'t', 20:'u', 21:'v', 22:'w', 23:'x', 24:'y',
         25:'z'}

inv_uppercase = {0:'A', 1:'B', 2:'C', 3:'D', 4:'E', 5:'F', 6:'G', 7:'H',
                 8:'I', 9:'J', 10:'K', 11:'L', 12:'M', 13:'N', 14:'O', 15:'P',
                 16:'Q', 17:'R', 18:'S', 19:'T', 20:'U', 21:'V', 22:'W', 23:'X',
                 24:'Y', 25:'Z'}

letter_count = {'A':0, 'B':0, 'C':0, 'D':0, 'E':0, 'F':0, 'G':0, 'H':0, 'I':0,
         'J':0, 'K':0, 'L':0, 'M':0, 'N':0, 'O':0, 'P':0, 'Q':0,
         'R':0, 'S':0,  'T':0, 'U':0, 'V':0, 'W':0, 'X':0, 'Y':0, 'Z':0}


class key(object):
    alpha=0
    beta=0
    gamma=0
    theta=0

# The extended Euclidean algorithm (EEA)
def egcd(a, b):
    x,y, u,v = 0,1, 1,0
    while a != 0:
        q, r = b//a, b%a
        m, n = x-u*q, y-v*q
        b,a, x,y, u,v = a,r, u,v, m,n
    gcd = b
    return gcd, x, y

# Modular inverse algorithm that uses EEA
def modinv(a, m):
    if a < 0:
        a = m+a
    gcd, x, y = egcd(a, m)
    if gcd != 1:
        return None  # modular inverse does not exist
    else:
        return x % m

# Vigènere cipher

#JR WYDUGQ AR LRG BTFWB’U UECDC YVTF S CYVNE LY JVS QZYWYDCJC, CAD FAC NRGQ KZTRAB MXYVTRAXIYY, YK SH GHC DOXRL DDYQES UWBG GIJLSPT UN SXF FILCSPT DMOX VB TFW RGNVC SXF YULYO QS TFW CGN. TFW GKQE PGYOF SCWWGQ TMG XCERMO PQE HGK BQYLGFQ INIR, SXF GO FAWURLD ZO YNS GF DGERMJ VGFT FAC DEOYV CJBUJVOTF SFGENQ CMDVKQE UADJ GHC VYQEWYQC QE SUWOR GHC TBKP-A-ZJKE SRME DJR LMO WCATCD. RG EEAGSNRD DJYO FIBW DQ FIBW LGGWCWX VUE TSBKBUQ GLLRCRK KPQ MSDDKCLGWN VUE FSJCEDQ LRCG IL JOCYIRQ VQQGCV YPYY GF RKF MGFN. DRTUWOP N GPSXF CIYFY CAD Y UOPGRC-LKDYE NAVGQ HGYR YVTF TYQXS USC UCAAW PQE A FSVH N DMROP GO USVM NBPWKUG, YCL RG RSQSIGQ IR OSVU TPWZKQARAYP. UIQ ZOCIY YJWU UULY VQBSCDI CG HGK CKQEQ. ZO FVD LGD MAOU ORCG TM VY YVTF LRQFE YJWU NNB ZKPQS, YFN YUEL, LY JVS CPMKGEB NSUVOL, GXG NRK KOGZEB DSCOLC LY DEUQZ KINILKD VUE ZGYMF OL LRG GAZDO, JR LSJMJRD YOKA YIIW K HEIEZDGAEB ZYTFE, ZSBGYY KACUVNE LRG CIYFY UGOMD. RG JARURGQ TFW OCFY USVM BF RZO QGHCJ SP SRMFD QS HGE, KPQ FMJ DJR FGJCV GIKW BGNLGROF GHYL RKF WYDU YNS BAPHRRCFD HEOK LRCG OD GDJRR KWX. JR EVHOTVELUOF N MMEOPGAPQ ZCAG MX CJNMC LRCG HC KRQHLB OKNX SM MXEBURZVA. GHC KGGNT ZMBUG TFJYWTH RZO UXIL GP JVS DGBGUEYV SP GILQ LGNDQ, SXF UE NSEURD YFN OBPNWN JVS ZJYPMEB XKER WGLR JVS FSXFXEPURKRF
def propertext(text):
  ctxt=""
  for element in text:
    if element == " " or element == "." or element == "," or element == "-" or element == "’":
      continue
    else:
      ctxt+=element
  return ctxt

vigeneretext = propertext("JR WYDUGQ AR LRG BTFWB’U UECDC YVTF S CYVNE LY JVS QZYWYDCJC, CAD FAC NRGQ KZTRAB MXYVTRAXIYY, YK SH GHC DOXRL DDYQES UWBG GIJLSPT UN SXF FILCSPT DMOX VB TFW RGNVC SXF YULYO QS TFW CGN. TFW GKQE PGYOF SCWWGQ TMG XCERMO PQE HGK BQYLGFQ INIR, SXF GO FAWURLD ZO YNS GF DGERMJ VGFT FAC DEOYV CJBUJVOTF SFGENQ CMDVKQE UADJ GHC VYQEWYQC QE SUWOR GHC TBKP-A-ZJKE SRME DJR LMO WCATCD. RG EEAGSNRD DJYO FIBW DQ FIBW LGGWCWX VUE TSBKBUQ GLLRCRK KPQ MSDDKCLGWN VUE FSJCEDQ LRCG IL JOCYIRQ VQQGCV YPYY GF RKF MGFN. DRTUWOP N GPSXF CIYFY CAD Y UOPGRC-LKDYE NAVGQ HGYR YVTF TYQXS USC UCAAW PQE A FSVH N DMROP GO USVM NBPWKUG, YCL RG RSQSIGQ IR OSVU TPWZKQARAYP. UIQ ZOCIY YJWU UULY VQBSCDI CG HGK CKQEQ. ZO FVD LGD MAOU ORCG TM VY YVTF LRQFE YJWU NNB ZKPQS, YFN YUEL, LY JVS CPMKGEB NSUVOL, GXG NRK KOGZEB DSCOLC LY DEUQZ KINILKD VUE ZGYMF OL LRG GAZDO, JR LSJMJRD YOKA YIIW K HEIEZDGAEB ZYTFE, ZSBGYY KACUVNE LRG CIYFY UGOMD. RG JARURGQ TFW OCFY USVM BF RZO QGHCJ SP SRMFD QS HGE, KPQ FMJ DJR FGJCV GIKW BGNLGROF GHYL RKF WYDU YNS BAPHRRCFD HEOK LRCG OD GDJRR KWX. JR EVHOTVELUOF N MMEOPGAPQ ZCAG MX CJNMC LRCG HC KRQHLB OKNX SM MXEBURZVA. GHC KGGNT ZMBUG TFJYWTH RZO UXIL GP JVS DGBGUEYV SP GILQ LGNDQ, SXF UE NSEURD YFN OBPNWN JVS ZJYPMEB XKER WGLR JVS FSXFXEPURKRF")


def keyfinervigenere(text): # Function that finds keylength with iterations
  copytext = "*" + text
  iteration = 1
  for i in range(50):
    coincidences = 0
    for i in range(len(text)):
      if(text[i] == copytext[i]):
        coincidences += 1
    print(iteration," -> ",coincidences)
    copytext = "*" + copytext
    iteration += 1

#keyfinervigenere(vigeneretext)

# every 6th iteration we can see the peaks. So Key Length is 6.
# 1  ->  33
# 2  ->  44
# 3  ->  29
# 4  ->  26
# 5  ->  35
# 6  ->  65
# 7  ->  22
# 8  ->  45
# 9  ->  42
# 10  ->  33
# 11  ->  46
# 12  ->  58
# 13  ->  38
# 14  ->  35
# 15  ->  43
# 16  ->  45
# 17  ->  43
# 18  ->  61

## after frequency analysis i found key is CNAYSK or (2,13,0,24,18,10)

alphabet = {
            'A':0, 'B':1, 'C':2, 'D':3, 'E':4, 'F':5, 
            'G':6, 'H':7, 'I':8, 'J':9, 'K':10, 'L':11, 
            'M':12, 'N':13, 'O':14, 'P':15, 'Q':16, 'R':17, 
            'S':18, 'T':19, 'U':20, 'V':21, 'W':22, 'X':23, 
            'Y':24, 'Z':25
           }

def convertkey(keystring):  # Convert string key to the list
  listkey = []
  for element in keystring:
    listkey.append(uppercase[element])
  return listkey

def vigenere_Decipher(text,key): # Function that solve vigenere Cipher
  key = convertkey("CNAYSK")
  plaintext = ""
  
  count = 0
  for i in range(len(text)):
    plaintext += inv_uppercase[((uppercase[text[i]] - key[count]) % 26)]
    count+=1
    if count == 6:
      count = 0

  return plaintext

vigenere_Decipher(vigeneretext,"CNAYSK")

#Answer is HEWALKEDATTHEOTHERSHEELSWITHASWINGTOHISSHOULDERSANDHISLEGSSPREADUNWITTINGLYASIFTHELEVELFLOORSWERETILTINGUPANDSINKINGDOWNTOTHEHEAVEANDLUNGEOFTHESEATHEWIDEROOMSSEEMEDTOONARROWFORHISROLLINGGAITANDTOHIMSELFHEWASINTERRORLESTHISBROADSHOULDERSSHOULDCOLLIDEWITHTHEDOORWAYSORSWEEPTHEBRICABRACFROMTHELOWMANTELHERECOILEDFROMSIDETOSIDEBETWEENTHEVARIOUSOBJECTSANDMULTIPLIEDTHEHAZARDSTHATINREALITYLODGEDONLYINHISMINDBETWEENAGRANDPIANOANDACENTRETABLEPILEDHIGHWITHBOOKSWASSPACEFORAHALFADOZENTOWALKABREASTYETHEESSAYEDITWITHTREPIDATIONHISHEAVYARMSHUNGLOOSELYATHISSIDESHEDIDNOTKNOWWHATTODOWITHTHOSEARMSANDHANDSANDWHENTOHISEXCITEDVISIONONEARMSEEMEDLIABLETOBRUSHAGAINSTTHEBOOKSONTHETABLEHELURCHEDAWAYLIKEAFRIGHTENEDHORSEBARELYMISSINGTHEPIANOSTOOLHEWATCHEDTHEEASYWALKOFTHEOTHERINFRONTOFHIMANDFORTHEFIRSTTIMEREALIZEDTHATHISWALKWASDIFFERENTFROMTHATOFOTHERMENHEEXPERIENCEDAMOMENTARYPANGOFSHAMETHATHESHOULDWALKSOUNCOUTHLYTHESWEATBURSTTHROUGHTHESKINOFHISFOREHEADINTINYBEADSANDHEPAUSEDANDMOPPEDHISBRONZEDFACEWITHHISHANDKERCHIEF